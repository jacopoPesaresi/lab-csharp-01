URL https://github.com/jacopoPesaresi/lab-csharp-01.git

CLONE git@github.com:jacopoPesaresi/lab-csharp-01.git

BRANCH master

LAB 1-Properties

LAB 2-ComplexAlgebra

CASA 3-Calculus
Non ho pensato di usare un Nullables quando non c'è una operazione settata su un + o un -, ma di usare un valore incompatibile con un qualche simbolo che racchiudesse una operazione matematica
ToString lievemente diverso, ma il succo è lo stesso
Ho previsto un metodo unico per eseguire il calcolo separato da quello pubblico, in quanto quello salva il risultato in Value mentre il resto dei calcoli deve essere salvato nel "tmpValue"
Invece di usare lo switch ho fatto lo scorrimento dei simboli matematici con quella che poteva divetare una catena di if-else
Per il resto, le differenze derivano dai punti cardine evidenziati sopra (principalmente da non aver usato il nullable e per non aver riciclato il metodo pubblico avendone creato un'altro)

CASA 4-Arrays
In MaxModulus ho usato un approccio algoritmistico (oltre che, alla fine, un foreach), partendo dal valore minore possibile in funzione dell'aspetto massimo... ma sono praticamente identiche
Clone è identica... se non fosse che ho esplicitato il costruttore dei Complex per creare 
[Dubbio: non c'è bisogno di creare un nuovo oggetto, per mantenere intatti i valori di array se quelli del clone vengono modificati, eseguendo una sorta di copia difensiva? O è intrinseca nella sintassi C#?]
SortByPhase praticamente come Clone
[e qui a maggior ragione sottolineo il mio dubbio]
ArrayToString è uguale anche quello, anche se io ho sfruttato più volte il + concatenatore riducendo quindi le righe di codice

CASA 5-Iterators
In Indexed invece di Tuple.Create ho usato il new Tuple
La Reduce la ho sviluppata usando sempre "seed"... può comunque andare o ogni modifica sarebbe stata "quadratica"? (nel senso, nei test ho visto che la modifica è un semplice incremento, quindi ancora accettabile per come ho strutturato il metodo (penso), ma se invece di un incremento era un *2 poteva essere un problema?)
SkipWhile la ho strutturata come una Filter inversa... TakeWhile invece è proprio la Filter... Non ci ho pensato mentre le sviluppavo, ops (avrei modificato il codice, ma come da specifiche preferisco lasciarlo così)
Integers lo ho sviluppato in un'unica riga, "senza fare una copia difensiva di start" (e senza neanche fare un ciclo while true)

CASA 6-Indexers

CASA 6-IndexersTests

